import { SorterStore } from './stores/SorterStore';
import { Heap } from '../../data-structures/heap';

export async function bubbleSort(this: SorterStore) {
  let swapped;
  do {
    swapped = false;
    for (let i = 1; i < this.array.length; i++) {
      if (this.comparegt(i - 1, i)) {
        await this.swapAndWait(i - 1, i);
        swapped = true;
      }
    }
  } while (swapped);
}
bubbleSort.displayName = 'Bubble Sort';

export async function insertionSort(this: SorterStore) {
  for (let i = 1; i < this.array.length; i++) {
    for (let j = i; j > 0 && this.comparegt(j - 1, j); j--) {
      await this.swapAndWait(j, j - 1);
    }
  }
}
insertionSort.displayName = 'Insertion Sort';

export async function selectionSort(this: SorterStore) {
  for (let i = 0; i < this.array.length - 1; i++) {
    let minIndex = i;
    for (let j = i + 1; j < this.array.length; j++) {
      if (this.comparelt(j, minIndex)) {
        minIndex = j;
      }
    }
    if (minIndex != i) {
      await this.swapAndWait(i, minIndex);
    }
  }
}
selectionSort.displayName = 'Selection Sort';

export async function quickSort(this: SorterStore) {
  await recursiveQuicksort.call(this, 0, this.array.length - 1);
}
quickSort.displayName = 'Quicksort (Lomuto)';

async function recursiveQuicksort(this: SorterStore, lo: number, hi: number) {
  if (lo >= hi || lo < 0) return;

  const p = await quicksortPartition.call(this, lo, hi);

  await recursiveQuicksort.call(this, lo, p - 1);
  await recursiveQuicksort.call(this, p + 1, hi);
}

async function quicksortPartition(this: SorterStore, lo: number, hi: number) {
  let i = lo - 1;

  for (let j = lo; j < hi; j++) {
    if (this.comparelte(j, hi)) {
      i++;
      await this.swapAndWait(i, j);
    }
  }

  i++;
  await this.swapAndWait(i, hi);
  return i;
}

export async function mergeSort(this: SorterStore) {
  await mergeSortSplit.call(this, this.array, 0, this.numCandles, [...this.array]);
}
mergeSort.displayName = 'Merge Sort (Top Down)';

async function mergeSortSplit(this: SorterStore, B: number[], begin: number, end: number, A: number[]) {
  if (end - begin <= 1) return;

  const middle = Math.floor((end + begin) / 2);

  await mergeSortSplit.call(this, A, begin, middle, B);
  await mergeSortSplit.call(this, A, middle, end, B);

  await merge.call(this, B, begin, middle, end, A);
}

async function merge(this: SorterStore, B: number[], begin: number, middle: number, end: number, A: number[]) {
  let i = begin;
  let j = middle;

  for (let k = begin; k < end; k++) {
    if (i < middle && j < end) this.comparelte(i, j);
    if (i < middle && (j >= end || A[i] <= A[j])) {
      B[k] = A[i];
      i++;
      await this.wait();
    } else {
      B[k] = A[j];
      j++;
      await this.wait();
    }
  }
}

export async function heapsort(this: SorterStore) {
  await heapify.call(this);

  let end = this.array.length - 1;
  while (end > 0) {
    await this.swapAndWait(end, 0);
    end--;
    await siftDown.call(this, 0, end);
  }
}
heapsort.displayName = 'Heap Sort';

function parent(i: number) {
  return Math.floor((i - 1) / 2);
}
function leftChild(i: number) {
  return 2 * i + 1;
}

async function heapify(this: SorterStore) {
  let start = parent(this.array.length - 1);
  while (start >= 0) {
    await siftDown.call(this, start, this.array.length - 1);
    start--;
  }
}

async function siftDown(this: SorterStore, start: number, end: number) {
  let root = start;

  while (leftChild(root) <= end) {
    const child = leftChild(root);
    let swap = root;

    if (this.comparelt(swap, child)) swap = child;
    if (child + 1 <= end && this.comparelt(swap, child + 1)) swap = child + 1;
    if (swap == root) return;
    else {
      await this.swapAndWait(root, swap);
      root = swap;
    }
  }
}

const ciuraGaps = [701, 301, 132, 57, 23, 10, 4, 1];
export async function shellSort(this: SorterStore) {
  for (const gap of ciuraGaps) {
    for (let i = gap; i < this.array.length; i++) {
      const temp = this.array[i];
      let j: number;
      for (j = i; j >= gap && this.array[j - gap] > temp; j -= gap) {
        this.array[j] = this.array[j - gap];
        await this.wait();
      }
      this.array[j] = temp;
      await this.wait();
    }
  }
}
shellSort.displayName = 'Shell Sort';

export async function countingSort(this: SorterStore) {
  let k = Math.max(...this.array);
  let t = 0;
  const temp = new Array(k + 1).fill(0);
  const display = new Array(this.array.length).fill(0);

  for (let i = 0; i < this.array.length; i++) {
    t = this.array[i];
    temp[t]++;
  }

  for (let i = 1; i <= k; i++) {
    temp[i] = temp[i] + temp[i - 1];
  }

  for (let i = this.array.length - 1; i >= 0; i--) {
    t = this.array[i];
    display[temp[t] - 1] = t;
    temp[t] = temp[t] - 1;
  }

  return display;
}
countingSort.displayName = 'Counting Sort';

export async function bucketSort(this: SorterStore) {
  let bucket = new Array(this.array.length);

  //Add bucket group
  for (let i = 0; i < this.array.length; i++) {
    bucket[i] = [];
  }

  //Add the elements in a same range in bucket
  for (let i = 0; i < this.array.length; i++) {
    let bucketIndex = Math.floor(this.array[i]) * this.array.length;
    bucket[bucketIndex].push(this.array[i]);
  }

  for (let i = 0; i < this.array.length; i++) {
    bucket[i].sort();
  }

  let index = 0;
  for (let i = 0; i < this.array.length; i++) {
    for (let j = 0, size = bucket[i].length; j < size; j++) {
      this.array[index++] = bucket[i][j];
    }
  }
}
bucketSort.displayName = 'Bucket Sort';

/*
const bucketSort = (arr, n = arr.length) => {
  //Create a bucket array
  let bucket = new Array(n);
  
  //Add bucket group
  for(let i = 0; i < n; i++){
    bucket[i] = [];
  }
  
  //Add the elements in a same range in bucket
  for(let i = 0; i < n; i++){
    let bucketIndex = Math.floor(arr[i]) * n;
    bucket[bucketIndex].push(arr[i]);
  }
  
  //Sort each bucket separately
  for(let i = 0; i < n; i++){
    bucket[i].sort();
  }
  
  // Get the sorted array
  let index = 0;
  for (let i = 0; i < n; i++) {
    for (let j = 0, size = bucket[i].length; j < size; j++) {
        arr[index++] = bucket[i][j];
    }
  }
}
*/
